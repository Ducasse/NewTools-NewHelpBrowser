'From Pharo9.0.0 of 14 April 2021 [Build information: Pharo-9.0.0+build.1317.sha.870e75f464b0973ca7b3efef6a924314694ade32 (64 Bit)] on 15 April 2021 at 2:31:24.573293 pm'!AbstractFileReference subclass: #FileReference	instanceVariableNames: 'filesystem'	classVariableNames: ''	package: 'FileSystem-Core-Public'!!FileReference commentStamp: '' prior: 0!I combine a filesystem and path, which is sufficient to refer to a concrete file or directory. I provide methods for navigating my filesystem, performing filesystem operations and opening and closing files. I am the primary mechanism for working with files and directories. ###Examples```| working |working := FileSystem disk workingDirectory.working files ``````| disk |disk := FileSystem disk.disk root.                               	"a reference to the root directory"disk working.                         	"a reference to the working directory"```!!FileReference methodsFor: 'resolving'!resolveString: aString 	| thePath |	thePath := filesystem pathFromString: aString.	^ filesystem referenceTo: (path resolve: thePath)! !!FileReference methodsFor: 'resolving'!resolveReference: aReference		^ (filesystem = aReference fileSystem or: [aReference isRelative])		ifTrue: [filesystem referenceTo: (path resolvePath: aReference path)]		ifFalse: [aReference]! !!FileReference methodsFor: 'resolving'!resolvePath: anObject	^ self withPath: (path resolve: anObject)! !!FileReference methodsFor: '*GT-InspectorExtensions-Core'!gtDisplayOn: stream	filesystem printPath: path on: stream! !!FileReference methodsFor: 'accessing'!permissions	^ filesystem permissions: self path! !!FileReference methodsFor: 'accessing'!fullPath	^ self path! !!FileReference methodsFor: 'accessing'!entry	"Return the entry (meta data) describing the receiver."	^ filesystem entryAt: path! !!FileReference methodsFor: 'accessing'!gid	"Return the gid of the file at aPath"	^ filesystem gidOf: path! !!FileReference methodsFor: 'accessing'!fileSystem	"Return the filesystem to which the receiver belong."	^ filesystem! !!FileReference methodsFor: 'accessing'!creationTime	"Answer the receivers creation time.	Note that the interpretation varies by platform."	^ filesystem creationTimeOf: self path! !!FileReference methodsFor: 'accessing'!fullName	"Return the full path name of the receiver."	^ filesystem stringFromPath: (filesystem resolve: path)! !!FileReference methodsFor: 'accessing'!targetPath	"Return the target file of the File described by aPath.  For a regular file, this is itself, for a symbolic link, it is the file pointed to by the symbolic link"	^ self class fileSystem: filesystem path: (filesystem targetPath: path)! !!FileReference methodsFor: 'accessing'!symlinkUid: uid gid: gid	"Set the owner and group of the receiver by numeric id.	An id of nil leaves it unchanged."	^filesystem file: self path symlinkUid: uid gid: gid.! !!FileReference methodsFor: 'accessing'!accessTime 	^ filesystem accessTimeOf: self path! !!FileReference methodsFor: 'accessing'!absolutePath	"Return the absolute of the receiver"	^ self path isRelative		ifFalse: [ self path ]		ifTrue: [ filesystem resolve: self path ]! !!FileReference methodsFor: 'accessing'!size	^ filesystem sizeOf: path! !!FileReference methodsFor: 'accessing'!deviceId	"Return the device id of the file at aPath"	^ filesystem deviceIdOf: path! !!FileReference methodsFor: 'accessing'!inode	"Return the inode of the file at aPath"	^ filesystem inodeOf: path! !!FileReference methodsFor: 'accessing'!resolve	^ self! !!FileReference methodsFor: 'accessing'!numberOfHardLinks	"Return the number of hard links to the File described by aPath"	^ filesystem numberOfHardLinks: path! !!FileReference methodsFor: 'accessing'!uid: uid gid: gid	"Set the owner and group of the receiver by numeric id.	An id of nil leaves it unchanged."	^filesystem file: self path uid: uid gid: gid! !!FileReference methodsFor: 'accessing'!modificationTime 	"Returns the last date of modification of self"	^ filesystem modificationTimeOf: self path! !!FileReference methodsFor: 'accessing'!symlinkEntry	"Return the symlink entry (meta data) describing the receiver."	^ filesystem symlinkEntryAt: path! !!FileReference methodsFor: 'accessing'!uid	"Return the gid of the file at aPath"	^ filesystem uidOf: path! !!FileReference methodsFor: 'accessing'!changeTime 	^ filesystem changeTimeOf: self path! !!FileReference methodsFor: 'testing'!isRoot	^ path isRoot! !!FileReference methodsFor: 'testing'!hasFiles	"Return whether the receiver has children that are files."	"FileSystem workingDirectory hasFiles"		^ filesystem hasFiles: path! !!FileReference methodsFor: 'testing'!isFile	^ filesystem isFile: path! !!FileReference methodsFor: 'testing'!isFIFO	"Return a boolean indicating whether the File described by aPath is FIFO (i.e. a pipe)"	^ filesystem isFIFO: path! !!FileReference methodsFor: 'testing'!hasDirectories	"Return whether the receiver has children that are directories."	"FileSystem workingDirectory hasDirectories"		^ filesystem hasDirectories: path! !!FileReference methodsFor: 'testing'!isSymlink	"Answer a boolean indicating whether the receiver is a symlink"	^ filesystem isSymlink: path! !!FileReference methodsFor: 'testing'!isExecutable	"Answer a boolean indicating whether the receiver has the executable flag set"	^ filesystem isExecutable: path! !!FileReference methodsFor: 'testing'!isAbsolute	^ path isAbsolute! !!FileReference methodsFor: 'testing'!isReadable	^ filesystem isReadable: path! !!FileReference methodsFor: 'testing'!isBlock	"Return a boolean indicating whether the File described by aPath is a block device"	^ filesystem isBlock: path! !!FileReference methodsFor: 'testing'!isSocket	"Return a boolean indicating whether the File described by aPath is a socket"	^ filesystem isSocket: path! !!FileReference methodsFor: 'testing'!isDirectory	^ filesystem isDirectory: path! !!FileReference methodsFor: 'testing'!exists	"Answer a boolean indicating whether the receiver exists on the file system"	^ filesystem exists: path! !!FileReference methodsFor: 'testing'!isWritable	^ filesystem isWritable: path! !!FileReference methodsFor: 'testing'!isRegular	"Return a boolean indicating whether the File described by aPath is a regular file"	^ filesystem isRegular: path! !!FileReference methodsFor: 'testing'!isRelative	^ path isRelative! !!FileReference methodsFor: 'testing'!hasChildren	"Return whether the receiver has any children."	"FileSystem workingDirectory hasChildren"		^ filesystem hasChildren: path! !!FileReference methodsFor: 'testing'!isCharacter	"Return a boolean indicating whether the File described by aPath is character based"	^ filesystem isCharacter: path! !!FileReference methodsFor: '*ston-core'!stonContainSubObjects	^ false! !!FileReference methodsFor: '*ston-core'!stonOn: stonWriter	self fileSystem isDiskFileSystem		ifTrue: [ | diskFilePath |			"in order to get $/ as delimiter and $. as working directory on all platforms"			diskFilePath := path isWorkingDirectory				ifTrue: [ '.' ]				ifFalse: [ path pathString ].			stonWriter 				writeObject: self 				named: STONFileReference stonName 				listSingleton: diskFilePath ]		ifFalse: [ 			super stonOn: stonWriter ]! !!FileReference methodsFor: 'comparing'!= other	"Two FileReferences are considered equal if they refer to the same file / directory.	As paths can have multiple relative representations, compare the absolute paths."	"Perform the path comparison last as conversion to absolute paths is relatively expensive"	^ self species = other species		and: [self fileSystem = other fileSystem			and: [self absolutePath = other absolutePath]]! !!FileReference methodsFor: 'comparing'!containsReference: aReference	^  aReference fileSystem = filesystem and: [path contains: aReference path]! !!FileReference methodsFor: 'comparing'!hash	^ path hash bitXor: filesystem hash! !!FileReference methodsFor: '*metacello-platform'!asRepositorySpecFor: aMetacelloMCProject  ^ aMetacelloMCProject repositorySpec    description: self fullName;    type: 'directory';    yourself! !!FileReference methodsFor: 'operations'!moveTo: aReference	"Move the receiver in the location passed as argument.		(FileSystem disk workingDirectory / 'paf' ) ensureCreateFile.	(FileSystem disk workingDirectory / 'fooFolder') ensureCreateDirectory. 	(FileSystem disk workingDirectory / 'paf' ) moveTo: (FileSystem disk workingDirectory / 'fooFolder' / 'paf')		Note that the receiver is modified to point to the new location."		| result |	result := self fileSystem 		move: self path		to: aReference resolve.	result ifNotNil: [		self setFileSystem: result fileSystem path: result path ].		! !!FileReference methodsFor: 'operations'!ensureCreateDirectory	"Create if necessary a directory for the receiver."	filesystem ensureCreateDirectory: path	! !!FileReference methodsFor: 'operations'!renameTo: newBasename		| destinationPath |	destinationPath := self fileSystem 		rename: self 		to: self parent / newBasename.		destinationPath ifNotNil: [		self 			setFileSystem: filesystem 			path: destinationPath ].	^ self		! !!FileReference methodsFor: 'operations'!permissions: permissions	"Set the receivers mode to anInteger (as defined by chmod())"	^filesystem file: self path posixPermissions: permissions posixPermission! !!FileReference methodsFor: 'operations'!copyTo: aFileReference	"Copy the receiver and create the argument, a file reference."		"If you want to copy a file from a folder into a given folder, the argument should not be the future parent folder	but a file reference of the future location.  	Therefore use 		(folder1 / 'foo.txt') copyTo: (folder2 / 'bar.txt')"			self isDirectory		ifTrue: [ aFileReference ensureCreateDirectory ]		ifFalse: [ filesystem copy: path toReference: aFileReference ]! !!FileReference methodsFor: 'operations'!delete	"Deletes the referenced file or directory. If the directory is not empty, 	raises an error. Use #deleteAll to delete with the children."	(self isDirectory and:[self hasChildren]) 		ifTrue:[DirectoryIsNotEmpty signalWith: self].	filesystem delete: path! !!FileReference methodsFor: 'operations'!deleteIfAbsent: aBlock	self exists 		ifTrue: [ self delete ]		ifFalse: aBlock! !!FileReference methodsFor: '*monticellofiletree-filesystem-utilities'!fileTreeUtilityClass    ^ MCFileTreeFileSystemUtils! !!FileReference methodsFor: 'navigating'!entries	"Return the entries (meta data - file description) of the direct children of the receiver"	^ self fileSystem entriesAt: self path ! !!FileReference methodsFor: 'navigating'!, extension	^ self withPath: self path, extension! !!FileReference methodsFor: 'converting'!asFileReference	^ self! !!FileReference methodsFor: 'converting'!asFileLocatorOrReference	^ self path asFileLocatorOrReference! !!FileReference methodsFor: 'converting' stamp: 'leofrere 4/15/2021 14:31'!asHelpTopic	self deprecated: 'use acceptVisitor instead'.	self isDirectory 			ifTrue: [ 			| rootTopic subTopics childrens |			rootTopic := HelpTopic named: self basenameWithoutExtension .			childrens := self children.						subTopics := childrens collect: [ :each |				| file |				file := each asFileReference.				file asHelpTopic ].			^ rootTopic subtopics: subTopics ] 				ifFalse: [ ^ HelpTopic title: self basenameWithoutExtension contents: self contents ]! !!FileReference methodsFor: 'converting'!asPath	"Answer the receivers path"	^path! !!FileReference methodsFor: 'converting'!asAbsolute	"Return the receiver as an absolute file reference."		^ self isAbsolute		ifTrue: [ self ]		ifFalse: [ filesystem referenceTo: (filesystem resolve: path) ]! !!FileReference methodsFor: 'initialization'!setFileSystem: aFilesystem path: aPath	filesystem := aFilesystem.	path := aPath! !!FileReference methodsFor: 'visiting' stamp: 'leofrere 4/15/2021 13:33'!acceptVisitor: aVisitor		self isDirectory 		ifTrue: [ ^ aVisitor visitFileReferenceDirectory: self ] 		ifFalse: [ ^ aVisitor visitFileReferenceFile: self ]		! !!FileReference methodsFor: 'copying'!copyWithPath: newPath	^ filesystem referenceTo: newPath! !!FileReference methodsFor: 'streams'!binaryReadStream	"Answer a buffered binary read stream on the receiver"		^ ZnBufferedReadStream on: (filesystem binaryReadStreamOn: self path)! !!FileReference methodsFor: 'streams'!writeStream		^ self writeStreamEncoded: 'utf8'! !!FileReference methodsFor: 'streams'!openWritable: aBoolean 	^ filesystem open: path writable: aBoolean! !!FileReference methodsFor: 'streams'!readStream	^ self readStreamEncoded: 'utf8'! !!FileReference methodsFor: 'streams'!binaryWriteStream	"Answer a buffered binary write stream on the receiver"	^ ZnBufferedWriteStream on: (filesystem binaryWriteStreamOn: self path)! !!FileReference methodsFor: 'streams'!unbufferedBinaryWriteStream	"Answer a binary read/write stream on the receiver"	^ filesystem binaryWriteStreamOn: self path! !!FileReference methodsFor: 'utilities'!nextNameFor: baseFileName extension: extension  "Assumes a file name includes a version number encoded as '.' followed by digits    preceding the file extension, e.g., games.22.ston   Increment the version number (of the largest one) and answer the new file name, e.g., games23.ston   If a version number is not found, set the version to 1 and answer a new file name"	"(FileSystem workingDirectory nextNameFor: 'games' extension: 'ston') asFileReference ensureCreateFile"	| version |	version := self versionNumberFor: baseFileName extension: extension.	^version		ifNil: [ baseFileName, '.1.', extension ]		ifNotNil: [ baseFileName , '.' , (version+1) asString , '.' , extension ]! !!FileReference methodsFor: 'utilities'!nextVersion	"Assumes a file (or folder) name includes a version number encoded as '.' followed by digits 	preceding the file extension.  Increment the version number and answer the new file name.	If a version number is not found, return just the file"	| parent basename nameWithoutExtension extension max index |	self exists		ifFalse: [ ^ self ].	parent := self parent.	extension := self extension.	basename := self basename.	nameWithoutExtension := basename copyFrom: 1 to: (basename size - extension size - 1).	"At this stage nameWithoutExtension may still include a version number.  Remove it if necessary"	index := nameWithoutExtension size.	[ index > 0 and: [ (nameWithoutExtension at: index) isDigit ] ] whileTrue:		[ index := index - 1 ].	((index between: 1 and: nameWithoutExtension size - 1) and: [ (nameWithoutExtension at: index) = $. ]) ifTrue: 		[ nameWithoutExtension := nameWithoutExtension copyFrom: 1 to: index-1 ].	max := parent versionNumberFor: nameWithoutExtension extension: extension.	^ parent / (nameWithoutExtension, '.', (max+1) asString) , self extension! !!FileReference methodsFor: 'utilities'!lastFileFor: baseFileName extension: extension	"Assumes a file is named using a version number encoded as '.' followed by digits  preceding the file extension, e.g., games.22.ston  Answer the file name with the largest number.  If a version number is not found, raises an error"	"FileSystem workingDirectory lastFileFor: 'games' extension: 'ston'"	| version |	version := self versionNumberFor: baseFileName extension: extension.	^(version		ifNil: [ self error: 'No file with number pattern' ]		ifNotNil: [ version = 0			ifTrue: [ baseFileName, '.', extension ]			ifFalse: [ baseFileName , '.' , version asString , '.' , extension ] ]) asFileReference ! !!FileReference methodsFor: '*Zinc-Resource-Meta-Core' stamp: 'nil'!mimeTypes	"Return the possible mime types for the given path."	^ filesystem mimeTypesAt: path! !!FileReference methodsFor: 'versions'!versionNumberFor: basename extension: extension	"Answer the latest (largest) version number for the specified file.	0 = basename.extension exists, but nothing later.	nil = no file exists"	| maxVersion |	maxVersion := 0.	self fileSystem childNamesAt: self path do: [ :child | | childVersion |		childVersion := self extractVersionNumberFrom: child basename: basename extension: extension.		childVersion ifNotNil: [ maxVersion := maxVersion max: childVersion ]].	^maxVersion = 0		ifTrue: [ (self / (basename, '.', extension)) asFileReference exists 			ifTrue: [ 0 ]			ifFalse: [ nil ] ]		ifFalse: [ maxVersion ]! !!FileReference methodsFor: 'versions'!extractVersionNumberFrom: filename basename: basename extension: extension	"Answer the version number written in filename considering 	that it consists of basename and extension.	For example filename=basename.10.extension will return 10.	filename=basename.extension without number will return 0	It returns nil if given file does not satisfy this pattern"	"ensure prefix basename."	| versionStart versionEnd |	(filename beginsWith: basename) ifFalse: [^nil].	(filename size > basename size and: [(filename at: basename size + 1) = $.]) 		ifFalse: [ ^nil ].	"ensure suffix .extension"	(filename endsWith: extension) ifFalse: [^nil].	(filename size > extension size and: [(filename at: filename size - extension size) = $.])		 ifFalse: [ ^nil ].		versionStart := basename size + 2.	versionEnd := filename size - extension size - 1.	versionStart to: versionEnd do: [:i | 		(filename at: i) isDigit ifFalse: [ ^nil ] ].	versionStart > versionEnd ifTrue: [ ^0]. "means pattern baseline.extension"	^(filename copyFrom: versionStart to: versionEnd) asNumber! !!FileReference methodsFor: 'printing'!pathString	"Return the full path name of the receiver."		^ filesystem stringFromPath: (filesystem resolve: path)! !!FileReference methodsFor: 'printing'!printOn: aStream	filesystem forReferencePrintOn: aStream.	filesystem printPath: path on: aStream! !!FileReference methodsFor: 'printing'!displayStringOn: stream	filesystem printPath: path on: stream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FileReference class	instanceVariableNames: ''!!FileReference class methodsFor: 'instance creation'!newTempFilePrefix: prefix suffix: suffix	| tmpDir random fileName |		tmpDir := FileLocator temp asFileReference.	[ 		random := UUID new asInteger asString.		fileName := prefix , random , suffix.		(tmpDir / fileName) exists ] whileTrue.	^ tmpDir / fileName! !!FileReference class methodsFor: 'instance creation'!fileSystem: aFilesystem path: aPath	^ self new setFileSystem: aFilesystem path: aPath! !!FileReference class methodsFor: 'cross platform'!/ aString	"Answer a reference to the argument resolved against the root of the current disk filesystem."		^ FileSystem disk / aString! !!FileReference class methodsFor: '*EyeInspector'!additionalInspectorClasses	^ super additionalInspectorClasses, { EyeFileSystemInspector }! !